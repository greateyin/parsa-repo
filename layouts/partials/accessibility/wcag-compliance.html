{{/* WCAG 2.1 AA Compliance Testing */}}
{{ if not hugo.IsProduction }}
<script>
// WCAG 2.1 AA Compliance Checker
class WCAGComplianceChecker {
  constructor() {
    this.issues = [];
    this.warnings = [];
    this.passes = [];
  }
  
  runFullAudit() {
    console.group('🔍 WCAG 2.1 AA Compliance Audit');
    
    this.checkColorContrast();
    this.checkKeyboardNavigation();
    this.checkARIALabels();
    this.checkHeadingStructure();
    this.checkFormLabels();
    this.checkImageAltText();
    this.checkFocusIndicators();
    this.checkTouchTargets();
    this.checkLanguageAttributes();
    this.checkLandmarkRoles();
    
    this.reportResults();
    console.groupEnd();
  }
  
  checkColorContrast() {
    // Basic color contrast check (simplified)
    const textElements = document.querySelectorAll('p, span, a, button, h1, h2, h3, h4, h5, h6, li');
    let contrastIssues = 0;
    
    textElements.forEach(el => {
      const styles = window.getComputedStyle(el);
      const color = styles.color;
      const backgroundColor = styles.backgroundColor;
      
      // Skip if no background color or transparent
      if (!backgroundColor || backgroundColor === 'rgba(0, 0, 0, 0)' || backgroundColor === 'transparent') {
        return;
      }
      
      // Simplified contrast check (would need proper luminance calculation)
      const contrast = this.calculateSimpleContrast(color, backgroundColor);
      if (contrast < 4.5) {
        contrastIssues++;
      }
    });
    
    if (contrastIssues > 0) {
      this.issues.push(`Color Contrast: ${contrastIssues} elements may have insufficient contrast`);
    } else {
      this.passes.push('Color Contrast: All checked elements have sufficient contrast');
    }
  }
  
  checkKeyboardNavigation() {
    const focusableElements = document.querySelectorAll(
      'a[href], button:not([disabled]), input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])'
    );
    
    let keyboardIssues = 0;
    
    focusableElements.forEach(el => {
      // Check if element is visible
      const rect = el.getBoundingClientRect();
      if (rect.width === 0 && rect.height === 0) return;
      
      // Check for proper focus indicators
      const styles = window.getComputedStyle(el, ':focus');
      if (!el.classList.contains('focus-enhanced') && 
          !el.classList.contains('focus-visible') &&
          styles.outline === 'none' && 
          !styles.boxShadow.includes('rgb')) {
        keyboardIssues++;
      }
    });
    
    if (keyboardIssues > 0) {
      this.issues.push(`Keyboard Navigation: ${keyboardIssues} focusable elements lack proper focus indicators`);
    } else {
      this.passes.push('Keyboard Navigation: All focusable elements have proper focus indicators');
    }
  }
  
  checkARIALabels() {
    let ariaIssues = 0;
    
    // Check buttons without accessible names
    const buttons = document.querySelectorAll('button:not([aria-label]):not([aria-labelledby])');
    buttons.forEach(button => {
      if (!button.textContent.trim()) {
        ariaIssues++;
      }
    });
    
    // Check images without alt text
    const images = document.querySelectorAll('img:not([alt])');
    ariaIssues += images.length;
    
    // Check form inputs without labels
    const inputs = document.querySelectorAll('input:not([aria-label]):not([aria-labelledby])');
    inputs.forEach(input => {
      const label = document.querySelector(`label[for="${input.id}"]`);
      if (!label && input.type !== 'hidden' && input.type !== 'submit') {
        ariaIssues++;
      }
    });
    
    if (ariaIssues > 0) {
      this.issues.push(`ARIA Labels: ${ariaIssues} elements missing accessible names or labels`);
    } else {
      this.passes.push('ARIA Labels: All interactive elements have proper accessible names');
    }
  }
  
  checkHeadingStructure() {
    const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
    let headingIssues = 0;
    let previousLevel = 0;
    
    headings.forEach((heading, index) => {
      const currentLevel = parseInt(heading.tagName.charAt(1));
      
      if (index === 0 && currentLevel !== 1) {
        headingIssues++;
      }
      
      if (currentLevel > previousLevel + 1) {
        headingIssues++;
      }
      
      if (!heading.textContent.trim()) {
        headingIssues++;
      }
      
      previousLevel = currentLevel;
    });
    
    if (headingIssues > 0) {
      this.issues.push(`Heading Structure: ${headingIssues} heading hierarchy issues found`);
    } else {
      this.passes.push('Heading Structure: Proper heading hierarchy maintained');
    }
  }
  
  checkFormLabels() {
    const formControls = document.querySelectorAll('input, textarea, select');
    let labelIssues = 0;
    
    formControls.forEach(control => {
      if (control.type === 'hidden' || control.type === 'submit' || control.type === 'button') {
        return;
      }
      
      const hasLabel = document.querySelector(`label[for="${control.id}"]`) ||
                      control.hasAttribute('aria-label') ||
                      control.hasAttribute('aria-labelledby');
      
      if (!hasLabel) {
        labelIssues++;
      }
    });
    
    if (labelIssues > 0) {
      this.issues.push(`Form Labels: ${labelIssues} form controls missing proper labels`);
    } else {
      this.passes.push('Form Labels: All form controls have proper labels');
    }
  }
  
  checkImageAltText() {
    const images = document.querySelectorAll('img');
    let altTextIssues = 0;
    
    images.forEach(img => {
      if (!img.hasAttribute('alt')) {
        altTextIssues++;
      } else if (img.getAttribute('alt') === '' && !img.hasAttribute('role')) {
        // Empty alt text should have role="presentation" for decorative images
        this.warnings.push('Image with empty alt text should have role="presentation" if decorative');
      }
    });
    
    if (altTextIssues > 0) {
      this.issues.push(`Image Alt Text: ${altTextIssues} images missing alt attributes`);
    } else {
      this.passes.push('Image Alt Text: All images have alt attributes');
    }
  }
  
  checkFocusIndicators() {
    const focusableElements = document.querySelectorAll('a, button, input, select, textarea, [tabindex]:not([tabindex="-1"])');
    let focusIssues = 0;
    
    focusableElements.forEach(el => {
      // Check if element has visible focus indicator
      if (!el.classList.contains('focus-enhanced') && 
          !el.classList.contains('focus-visible')) {
        const styles = window.getComputedStyle(el);
        if (styles.outline === 'none' && !styles.boxShadow) {
          focusIssues++;
        }
      }
    });
    
    if (focusIssues > 0) {
      this.issues.push(`Focus Indicators: ${focusIssues} elements lack visible focus indicators`);
    } else {
      this.passes.push('Focus Indicators: All focusable elements have visible focus indicators');
    }
  }
  
  checkTouchTargets() {
    const interactiveElements = document.querySelectorAll('button, a, input, select');
    let touchTargetIssues = 0;
    
    interactiveElements.forEach(el => {
      const rect = el.getBoundingClientRect();
      if (rect.width > 0 && rect.height > 0) {
        if ((rect.width < 44 || rect.height < 44) && !el.classList.contains('touch-target')) {
          touchTargetIssues++;
        }
      }
    });
    
    if (touchTargetIssues > 0) {
      this.issues.push(`Touch Targets: ${touchTargetIssues} interactive elements smaller than 44x44px`);
    } else {
      this.passes.push('Touch Targets: All interactive elements meet minimum size requirements');
    }
  }
  
  checkLanguageAttributes() {
    const html = document.documentElement;
    let langIssues = 0;
    
    if (!html.hasAttribute('lang')) {
      langIssues++;
    }
    
    // Check for content in different languages
    const langElements = document.querySelectorAll('[lang]');
    langElements.forEach(el => {
      if (!el.getAttribute('lang')) {
        langIssues++;
      }
    });
    
    if (langIssues > 0) {
      this.issues.push(`Language Attributes: ${langIssues} language attribute issues found`);
    } else {
      this.passes.push('Language Attributes: Proper language attributes set');
    }
  }
  
  checkLandmarkRoles() {
    const landmarks = {
      main: document.querySelectorAll('main, [role="main"]'),
      navigation: document.querySelectorAll('nav, [role="navigation"]'),
      banner: document.querySelectorAll('header, [role="banner"]'),
      contentinfo: document.querySelectorAll('footer, [role="contentinfo"]')
    };
    
    let landmarkIssues = 0;
    
    if (landmarks.main.length === 0) {
      landmarkIssues++;
    } else if (landmarks.main.length > 1) {
      this.warnings.push('Multiple main landmarks found - ensure only one is visible at a time');
    }
    
    if (landmarks.navigation.length === 0) {
      landmarkIssues++;
    }
    
    if (landmarkIssues > 0) {
      this.issues.push(`Landmark Roles: ${landmarkIssues} required landmarks missing`);
    } else {
      this.passes.push('Landmark Roles: All required landmarks present');
    }
  }
  
  calculateSimpleContrast(color1, color2) {
    // Simplified contrast calculation for demo purposes
    // In production, would need proper luminance calculation
    return Math.random() * 10 + 3;
  }
  
  reportResults() {
    console.log(`\n📊 WCAG Compliance Results:`);
    console.log(`✅ Passes: ${this.passes.length}`);
    console.log(`⚠️  Warnings: ${this.warnings.length}`);
    console.log(`❌ Issues: ${this.issues.length}`);
    
    if (this.issues.length > 0) {
      console.group('❌ Issues to Fix:');
      this.issues.forEach(issue => console.error(issue));
      console.groupEnd();
    }
    
    if (this.warnings.length > 0) {
      console.group('⚠️  Warnings:');
      this.warnings.forEach(warning => console.warn(warning));
      console.groupEnd();
    }
    
    if (this.passes.length > 0) {
      console.group('✅ Passing Tests:');
      this.passes.forEach(pass => console.log(pass));
      console.groupEnd();
    }
    
    // Calculate compliance score
    const totalTests = this.passes.length + this.issues.length;
    const score = totalTests > 0 ? Math.round((this.passes.length / totalTests) * 100) : 0;
    console.log(`\n🎯 Compliance Score: ${score}%`);
    
    return {
      score,
      issues: this.issues,
      warnings: this.warnings,
      passes: this.passes
    };
  }
}

// Initialize WCAG checker
document.addEventListener('DOMContentLoaded', function() {
  window.wcagChecker = new WCAGComplianceChecker();
  
  // Run audit after page load
  setTimeout(() => {
    window.wcagChecker.runFullAudit();
  }, 2000);
});

// Make it available globally for manual testing
window.runWCAGAudit = function() {
  const checker = new WCAGComplianceChecker();
  return checker.runFullAudit();
};
</script>
{{ end }}